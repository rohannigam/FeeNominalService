  /* Important Notes on Implementation
  - We want to use API Access key instead of JWT token for the FeeNominalService (Done)
  - We want to swtich to using AWS Secret Manager to store the API Access Key  
  - We want to use the AWS SDK to get the API Access Key from the Secret Manager so research needed on how to do this
  - We want to make sure connection between DataCenter (GR2) for MerchantPortal->FeeNominalService->Interpayments is secure
  - We want to make sure connection between DataCenter (GR2) for XiPayWSServers->FeeNominalService->Interpayments is secure
  - We can ensure the first half this by making sure the API Access Key is not exposed and is accessed via VPC endpoints

  TODO:
  5/17/2025
  - Service provider tables Implementation (Done)
  - API Key Rotation Process
  - Error Handling in API Responses.
  - Merchant validation endpoints
  - Onboarding flow documentation.
  - Network timeouts to providers.
  - Make changes to code base to reflect all init.sql changes to 'id' fields. (Done)

  - Changes to Merchant addition:
    ok let me tell you a little about what i am thinking. So as i mentioned before, there is going to be  an on prem onboarding portal 
    that will register its own merchant to our FeeNominalService using onboarding endpoints. In the externalId we are going to pass 
    the merchantId field from that onboarding portal. Then there would be a generate button that will call 
    onboarding/initialApiKeyGenerate endpoint where in we should be just passin in externalId and a merchant Name and possibly a 
    unique merchantGUID that onboarding portal has tied to that externalId in its DB and then I think we should return a unique
    merchantGuid from FeeNominalService along with unique ApiKey and a secret to go with it along with other existing fields we 
    added support for already. 
  */

  /*With respect to supporting mulitple API Keys per single Merchant
  Based on your requirements, here's my opinion on implementing multiple API keys per merchant:

1. **Database Schema Changes Needed:**
```sql
-- Merchant table to store merchant information
CREATE TABLE merchants (
    id UUID PRIMARY KEY,
    merchant_id VARCHAR(50) UNIQUE,  -- External merchant ID from on-prem systems
    name VARCHAR(255),
    status VARCHAR(20),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- API Keys table to store multiple keys per merchant
CREATE TABLE api_keys (
    id UUID PRIMARY KEY,
    merchant_id UUID REFERENCES merchants(id),
    key VARCHAR(255) UNIQUE,
    secret VARCHAR(255),
    description VARCHAR(255),
    rate_limit INTEGER,
    allowed_endpoints TEXT[],
    status VARCHAR(20),  -- ACTIVE, REVOKED, EXPIRED
    created_at TIMESTAMP,
    last_rotated_at TIMESTAMP,
    revoked_at TIMESTAMP,
    created_by VARCHAR(50),  -- Which on-prem service created this key
    external_reference_id VARCHAR(255)  -- Reference ID from on-prem system
);

-- API Key Usage table for audit and rate limiting
CREATE TABLE api_key_usage (
    id UUID PRIMARY KEY,
    api_key_id UUID REFERENCES api_keys(id),
    endpoint VARCHAR(255),
    request_count INTEGER,
    last_used_at TIMESTAMP
);
```

2. **Key Management Strategy:**
- Each API key should have a unique identifier within the merchant's scope
- Keys can be tagged with their purpose (e.g., "Surcharge Calculation", "Refund Processing")
- Keys can have different rate limits and endpoint permissions
- Keys can be created by different on-prem services

3. **API Key Generation Flow:**
```
On-Prem Service -> This Service
1. On-prem service calls with:
   - External merchant ID
   - Key purpose/description
   - Required permissions
   - External reference ID
2. This service:
   - Maps external merchant ID to internal merchant
   - Generates new API key
   - Stores with reference to on-prem system
   - Returns key details
```

4. **Authentication Flow:**
```
On-Prem Service -> This Service
1. On-prem service includes:
   - API Key
   - Merchant ID
   - Signature
2. This service:
   - Validates merchant exists
   - Finds API key for merchant
   - Validates key is active
   - Checks rate limits
   - Validates signature
```

5. **Key Features to Consider:**
- Key expiration dates
- Key rotation policies
- Usage tracking per key
- Different rate limits per key
- Different endpoint permissions per key
- Audit logging of key usage
- Key status tracking

6. **Security Considerations:**
- Each key should have its own secret
- Keys should be stored securely (AWS Secrets Manager)
- Keys should be rotated periodically
- Keys should be revocable individually
- Keys should have usage monitoring

7. **Integration Points:**
- On-prem onboarding portal
- SOAP web services
- Internal service authentication
- External service authentication

8. **Monitoring and Management:**
- Track key usage per merchant
- Monitor rate limit compliance
- Track key creation and revocation
- Audit key usage patterns
- Alert on suspicious activity

9. **Key States:**
- ACTIVE: Key is valid and can be used
- REVOKED: Key has been manually revoked
- EXPIRED: Key has reached its expiration date
- ROTATED: Key has been rotated (old version)

10. **Rate Limiting Strategy:**
- Per-key rate limits
- Per-merchant rate limits
- Per-endpoint rate limits
- Burst capacity handling

Would you like me to elaborate on any of these aspects or discuss specific implementation details?

  
  */

/*DB Tables so far

-- Merchants table
CREATE TABLE merchants (
    id UUID PRIMARY KEY,
    external_id VARCHAR(50) UNIQUE,  -- Merchant ID from onboarding portal
    name VARCHAR(255),
    status VARCHAR(20),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    created_by VARCHAR(50)           -- Admin user ID from onboarding portal
);

-- API Keys table
CREATE TABLE api_keys (
    id UUID PRIMARY KEY,
    merchant_id UUID REFERENCES merchants(id),
    key VARCHAR(255) UNIQUE,  --Only store public key
    secret VARCHAR(255), ---DELETE This goes in AWS SEcrets Manger
    description VARCHAR(255),
    rate_limit INTEGER,
    allowed_endpoints TEXT[],
    status VARCHAR(20),
    created_at TIMESTAMP,
    last_rotated_at TIMESTAMP,
    revoked_at TIMESTAMP,
    created_by VARCHAR(50),          -- Admin user ID from onboarding portal
    onboarding_reference VARCHAR(50)  -- Reference ID from onboarding portal
);



*/

************************************************************************
6/20/2025 - Weekly Summary & Major Platform Overhaul
************************************************************************

### 1. üîê Security & Authentication Overhaul
- Implemented merchant-specific access control with `X-Merchant-ID` header requirement
- Enhanced request signing with proper signature calculation (`timestamp|nonce|merchantId|apiKey`)
- Added merchant ownership validation for all surcharge provider operations
- Fixed security vulnerability where merchants could access other merchants' providers

### 2. üèóÔ∏è RESTful API Architecture Redesign
- Migrated from `/api/v1/surcharge-providers` to `/api/v1/merchants/{merchantId}/surcharge-providers`
- Implemented proper resource-based URL patterns for better scalability
- Added comprehensive merchant isolation ensuring data separation between tenants
- Updated all endpoints to follow consistent RESTful conventions

### 3. üóÑÔ∏è Database & Data Management Enhancements
- Implemented soft delete functionality with "DELETED" status instead of hard deletes
- Added restore capability for reactivating deleted providers
- Fixed EF Core shadow property issues and type mismatches (Guid vs string)
- Added missing database columns (`average_response_time`, `SurchargeProviderId`)
- Created composite unique constraints for provider codes per merchant

### 4. ‚öôÔ∏è Advanced Configuration & Validation System
- Built comprehensive credentials schema validation with field type checking (JWT, API_KEY, EMAIL, URL)
- Implemented single API call provider creation with configuration
- Added configurable validation settings (`SurchargeProviderValidationSettings`)
- Created primary configuration concept with usage tracking and metadata support
- Enhanced credential storage with encryption and secure management

### 5. üîÑ Surcharge Model Evolution & Transaction System
- **Deprecated** old `/api/v1/surchargefee/calculate` endpoints in favor of workflow-based approach
- **Introduced** new surcharge transaction model with `/api/v1/surcharge/auth`, `/api/v1/surcharge/refund`, `/api/v1/surcharge/void` endpoints
- **Implemented** direct integration with surcharge providers (like Interpayments) instead of simple fee calculation
- **Added** transaction storage and tracking in database with `SurchargeTransaction` model
- **Enhanced** provider configuration system to support actual API integrations rather than just fee calculations

**Impact**: Transformed FeeNominalService from a simple fee calculator into a comprehensive payment processing platform with proper multi-tenancy support, advanced configuration management, and direct provider integrations for real transaction processing.

************************************************************************
6/27/2025 - Weekly Summary & Surcharge Auth Workflow Completion
************************************************************************

## üìã Weekly Summary: FeeNominalService Changes

### üéØ Key Changes Summary (6 Points):

1. **üîê Security Enhancements**: Fixed critical merchant isolation vulnerability in transaction lookups, enforced provider config matching for follow-up auths, and enhanced request signing validation.

2. **üìù API Documentation Cleanup**: Removed stale endpoints from HTTP files and Postman collections, updated all request/response examples to match current models, and reorganized endpoint documentation for logical flow.

3. **‚öôÔ∏è Configuration Cleanup**: Removed unused Interpayments configuration from appsettings files, cleaned up legacy database migration files, and updated Swagger security schemes to reflect actual API key authentication.

4. **üõ†Ô∏è Code Quality Improvements**: Fixed null reference warnings throughout the codebase, improved error handling to return validation errors in responses instead of throwing exceptions, and enhanced XML documentation for Swagger.

5. **üîÑ Surcharge Auth Workflow**: Implemented complete end-to-end support for initial auth and follow-up auth using providerTransactionId, with proper validation, security checks, and error handling.

6. **üìä Database & Migration Management**: Removed legacy transaction tables, cleaned up unused migration files, and ensured database schema reflects current application state.

### üö¶ Surcharge Auth & Follow-Up Workflow: End-to-End Support
- The `/api/v1/surcharge/auth` endpoint now fully supports both initial and follow-up auth flows.
- All validation, security, and error handling is robust and consistent with the latest requirements.
- Merchant isolation and provider config matching are strictly enforced for all auth and follow-up requests.
- API documentation, Postman collections, and HTTP files are fully up to date and reflect the current contract.
- End-to-end testing and validation have been completed for all surcharge auth scenarios.
	
